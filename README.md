# -6-

## 学习内容：
  继续上一周，学习了各种最短路问题（Dijkstra、bellman-ford、spfa、Floyd），并复习了之前的内容（KMP，Trie树，并查集、堆、哈希表），重新看了一边视频。
  
## 笔记

### KMP算法：
  一种字符串的模式匹配算法，重点是构建模式串的next数组

### Trie树：
  高效地存储和查找字符串集合的数据结构
  定义：int son[N][26], cnt[N], idx;
  利用了公共前缀，查找是只需要找到下一个字母的地址、
  
### 并查集
  快速将两个集合合并，并回答两个元素是否在一个集合当中
  return x == fa[x] ? x : fa[x] = find(fa[x])
  
### 堆
  一个完全二叉树，下标x位置的左儿子：2 * x，右儿子：2 * x + 1.下标从1开始
  基本操作：down(x)和up(x)
  
### 哈希表
  常用哈希函数：k = (x % N + N) % N;
  存储：开放寻址法，拉链法
  
### 字符串哈希方式
  字符串前缀哈希法
  k = h[k] - h[l-1] * p^(r-l+1)
  
### Dijkstra
  使用一个 dist[] 数组用来存储从源点到其它点的距离，初始化 dist[1] = 0 ，其它点的 dist 值为 正无穷大（可以使用一个很大的数来表示，比如 0x3f3f3f3f)。
  找到一个尚未确定并且距离起点距离最近的点 t。然后标记该节点。
  扫描节点 t 的所有 出边（t -> j)，如果 源点 到 j 的距离比源点到 t 再从 t 到 j 的距离 g[t][j] 之和大，那么就使 dist[j] = dist[t] + g[t][j]。
  重复步骤 2 和 3 直到所有的点都被标记。
  
### bellman-ford算法
  不能有负权回路
  初始化所有dist[s],源点dist[s]=0,其他dist[s]=INF
  进行n-1次循环，在循环体中遍历所有的边，进行松弛计算（dist[b] = min(dist[b], dist[a] + w)）
  
### SPFA算法
  1定义一个队列q，一个标记数组st[N]用来标记某点是否在队列中。数组dist[N]，用来存储起点到某个点的最短距离。
  2初始化dist数组为正无穷，dist[1] = 0，st[1] = true，将1加入队列。
  3当队列非空时继续
  4队首出队，并枚举队首t的子节点j，设父节点到子节点的距离为s，如果dist[t] + s < dist[j]时就更新dist[j]，如果j没有在队列中，就将j入队
  5继续第3、4步

### Floyd算法
  还不懂
